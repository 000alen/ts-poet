import { promises as fs } from "fs";
import { dirname } from "path";
import { Code, DPrintOptions, ToStringOpts } from "./Code";
import { createHash } from "crypto";

export interface CodegenFile {
  name: string;
  contents: Code | string;
  /** Whether to generate the file just once, or overwrite it each time. */
  overwrite: boolean;
  /** Whether to use a `hash` comment hint to conditionally generate files (avoids format cost). */
  hash?: boolean;
  /** File-specific `toString` opts. */
  toStringOpts?: ToStringOpts;
}

export interface SaveFilesOpts {
  /** The tool name, i.e. `joist-codegen` or `ts-proto`; used in file prefix for overwrite: true. Defaults to ts-poet. */
  toolName?: string;
  /** The base directory to output to, defaults to `./`. */
  directory?: string;
  /** The files to generate. */
  files: CodegenFile[];
  /** The default toString opts, i.e. dprint settings, etc. */
  toStringOpts?: ToStringOpts;
}

/**
 * Saves multiple {@link CodegenFile}s.
 */
export async function saveFiles(opts: SaveFilesOpts): Promise<void> {
  const { toolName = "ts-poet", directory = "./", files, toStringOpts = {} } = opts;
  await Promise.all(
    files.map(async (file) => {
      const path = `${directory}/${file.name}`;

      // We might be writing to a subdirectory, so check this for each file
      await fs.mkdir(dirname(path), { recursive: true });
      const exists = await trueIfResolved(fs.access(path));

      if (file.overwrite) {
        if (!file.hash) {
          // Just write the file w/o the hash hint (i.e. for JSON/etc)
          await fs.writeFile(path, contentToString(file, toStringOpts));
        } else {
          // Create a hash of the unformatted option (to avoid the cost of formatting)
          const hash = sha1(contentToString(file, { ...toStringOpts, format: false }));
          if (exists) {
            const existing = (await fs.readFile(path)).toString();
            const match = existing.match(/\(hash=([0-9a-z]+)\)/);
            if (match && match[1] === hash) return;
          }
          // Now write the formatted out, but tagged with the unformatted version
          await fs.writeFile(
            path,
            `// Generated by ${toolName} (hash=${hash})\n` + contentToString(file, toStringOpts)
          );
        }
      } else if (!exists) {
        await fs.writeFile(path, contentToString(file, {}));
      }
    })
  );
}

function contentToString(file: CodegenFile, toStringOpts: ToStringOpts): string {
  if (typeof file.contents === "string") {
    return file.contents;
  }
  // Do a lazy/by-hand deep merge of toStringOpts and file.toStringOpts
  return file.contents.toString({
    path: file.name,
    ...toStringOpts,
    ...file.toStringOpts,
    dprintOptions: {
      ...toStringOpts.dprintOptions,
      ...file.toStringOpts?.dprintOptions,
    },
  });
}

// We purposefully use sha1 for speed b/c this isn't for crypto/auth
function sha1(content: string): string {
  const sum = createHash("sha1");
  sum.update(content);
  return sum.digest("hex").substring(0, 6);
}

/** Returns true if `p` is resolved, otherwise false if it is rejected. */
async function trueIfResolved(p: Promise<unknown>): Promise<boolean> {
  return p.then(
    () => true,
    () => false
  );
}
